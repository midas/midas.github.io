<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[respond_to do |jason|]]></title>
  <link href="http://blog.jasonharrelson.com/atom.xml" rel="self"/>
  <link href="http://blog.jasonharrelson.com/"/>
  <updated>2014-03-07T22:12:14-06:00</updated>
  <id>http://blog.jasonharrelson.com/</id>
  <author>
    <name><![CDATA[C. Jason Harrelson]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[How I Design Rails Applications: Part 1]]></title>
    <link href="http://blog.jasonharrelson.com/blog/2014/03/07/how-i-design-rails-applications-part-1/"/>
    <updated>2014-03-07T18:56:30-06:00</updated>
    <id>http://blog.jasonharrelson.com/blog/2014/03/07/how-i-design-rails-applications-part-1</id>
    <content type="html"><![CDATA[<p>I have been thinking and experimenting with different techniques to make Rails applications manageable as they grow for about 2 years now.  This exercise is not because I desire to add layers/complexity to my Rails applications, but because I have experienced the pain that a Rails application can provide as it matures.  In this multi-part series I will break down some of the successful techniques I am using to achieve my goals.</p>

<p>One of my starting places was this <a href="http://blog.codeclimate.com/blog/2012/10/17/7-ways-to-decompose-fat-activerecord-models/">article by Bryan Helmkamp</a>.  I will often reference this article in this series.  Thanks Bryan for sharing your techniques.</p>

<p>I agree with Bryan the suggestion to make &ldquo;fat models&rdquo; is not a best practice.  The model should not contain logic that does not directly correspond to reading/writing to the database.</p>

<h2>Part 1</h2>

<p>The first technique Bryan discusses in his article is to &ldquo;Extract Value Objects.&rdquo;  According to Bryan, value objects are, &ldquo;simple objects whose equality is dependent on their value rather than an identity.&rdquo;  This is an important conecpt taken from domain driven design.  In his book on DDD, Eric Evans states: &ldquo;Many objects have no conceptual identity.  These objects describe characteristics of a thing.&rdquo;</p>

<p>A great example of a value object is color:</p>

<div>
  <pre><code class='ruby'>class Color
  include Comparable

  def initialize(key)
    @key = key
  end

  def &lt;=&gt;(other)
    other.to_s &lt;=&gt; to_s
  end

  def eql?(other)
    to_s == other.to_s
  end

  def to_s
    @key.to_s
  end
end</code></pre>
</div>


<h2>Value Objects in the Model</h2>

<p>It is common practice for developers to define value objects in a model, usually as a constant in the model.</p>

<div>
  <pre><code class='ruby'>class Car &lt; ActiveRecord::Base
  COLOR = %w(
    black
    blue
    green
  )
end</code></pre>
</div>


<p>This practice is not good because the value object may be used in attribute(s) of a model, but has nothing directly to do with the domain the model is representing.  Defining value objects inline in the model class carries the at least following disadvantages:</p>

<ul>
<li>Impossible to add functionality to value object without further polluting the model</li>
<li>Limits reuse of the value object</li>
<li>Harder to test</li>
</ul>


<h2>Value Objects in the Database</h2>

<p>Quite often, developers will include value objects in the database as a model.  This is also bad form.  The value object is not dynamic so it does not necessitate use of the database.  In addition, the value object has no identity, so we do not need a keying system.  The only value the database really provides in this case is the limiting of the valid values for a value object to some predefined set that can be enforced.</p>

<h2>Enumerative Gem</h2>

<p>Enter the <a href="https://github.com/ninja-loss/enumerative">enumerative gem</a>.  This gem was authored by <a href="https://github.com/njonsson">Nils Jonsson</a> and myself.  The enumerative gem provides the tools necessary to create value objects that are limited to a finite set of valid values.</p>

<p>An enumeration for color might be implemented like:</p>

<div>
  <pre><code class='ruby'>class Color

  def self.valid_keys
    %w(
      black
      blue
      green
    )
  end

  include Enumerative::Enumeration

end</code></pre>
</div>


<p>In addition, you must add the translations for the enumeration&rsquo;s values to the <code>config/en.yml</code> file:</p>

<div>
  <pre><code class='ruby'>en:
  enumerations:
    color:
      black: Black
      blue: Blue
      green: Green</code></pre>
</div>


<p>Now you can use the enumeration.</p>

<div>
  <pre><code class='ruby'>Color::BLACK # #&lt;Color:0x000001015e6aa8 @key=&quot;black&quot;&gt;
Color::BLACK.key # &quot;black&quot;
Color::BLACK.value # &quot;Black&quot;
Color.to_select # [[&quot;Black&quot;, &quot;black&quot;], [&quot;Blue&quot;, &quot;blue&quot;], [&quot;Green&quot;, &quot;green&quot;]]
Color.new(&#39;black&#39;).valid? # true
Color.new(&#39;some invalid value&#39;).valid? # false</code></pre>
</div>


<p>The initiatlizer is very forgiving of the values it will accept so that it can be used to easily standardize input, etc.</p>

<div>
  <pre><code class='ruby'>Color.new(Color::BLACK) # #&lt;Color:0x000001015e7aa0 @key=&quot;black&quot;&gt;
Color.new(&#39;black&#39;) # #&lt;Color:0x000001015e7aa0 @key=&quot;black&quot;&gt;
Color.new(key: &#39;black&#39;) # #&lt;Color:0x000001015e7aa0 @key=&quot;black&quot;&gt;
Color.new(key: :black) # #&lt;Color:0x000001015e7aa0 @key=&quot;black&quot;&gt;</code></pre>
</div>


<h4>HasEnumeration Module</h4>

<p>It gets even more exciting when you want to use it in a model.  If you included the <code>Enumerative::HasEnumeration</code> module you get automatic casting from the key that is stored in the database to the type of the enumeration your attribute is defined as on a read and back to the key for storage on a write.</p>

<div>
  <pre><code class='ruby'>class Car &lt; ActiveRecord::Base
  include Enumerative::HasEnumeration

  has_enumeration color, from: Color
end</code></pre>
</div>


<p>Convenience when you read from the database:</p>

<div>
  <pre><code class='ruby'>car = Car.first
car.color_before_type_cast # &quot;black&quot;
car.color # #&lt;Color:0x000001015e7aa0 @key=&quot;black&quot;&gt;</code></pre>
</div>


<p>Convenience when you write to the database</p>

<div>
  <pre><code class='ruby'>car = Car.new
car.color = Color::BLACK
color.save!
car.reload
car.color_before_type_cast # &quot;black&quot;
car.color # #&lt;Color:0x000001015e7aa0 @key=&quot;black&quot;&gt;</code></pre>
</div>


<h4>Testing Enumerations</h4>

<p>Enumerative provides some a shared spec for easier specing of enumerations.  Following is an example spec for the color enumeration.</p>

<div>
  <pre><code class='ruby'>require &#39;spec_helper&#39;
require &#39;enumerative/enumeration_sharedspec&#39;

describe Color do

  it_should_behave_like &#39;an Enumeration&#39;

  def self.keys
    %w(
      black
      blue
      green
    )
  end

  self.keys.each do |key|
    const = key.upcase

    it &quot;should have #{const}&quot; do
      described_class.const_get( const ).should be_valid
    end
  end

  it &quot;should have the correct select-box values&quot; do
    described_class.to_select.should == [
      [&quot;Black&quot;, &quot;black&quot;],
      [&quot;Blue&quot;, &quot;blue&quot;],
      [&quot;Green&quot;, &quot;green&quot;]
    ]
  end
end</code></pre>
</div>


<h2>Project Organization</h2>

<p>I recommend placing enumerations in the <code>app/enumerations</code> directory.</p>

<h2>Conclusion</h2>

<p>With very little effort we have extracted our value object out of the database and retained the ability to limit the valid values to a finite set.  We can also use our value object in a model and persist the model&rsquo;s value for the enumeration in the database.  Most importantly, we have successfully removed a common contributer to making Rails models bloated and unmanageable.</p>

<p>Stay tuned for the next installment in the series.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby, OOP, Events and the Tell Don't Ask Principle]]></title>
    <link href="http://blog.jasonharrelson.com/blog/2014/03/04/ruby-oop-events-and-the-tell-dont-ask-principle/"/>
    <updated>2014-03-04T22:11:00-06:00</updated>
    <id>http://blog.jasonharrelson.com/blog/2014/03/04/ruby-oop-events-and-the-tell-dont-ask-principle</id>
    <content type="html"><![CDATA[<h2>Background</h2>

<p>Ignoring the existence of events in a program leads to harder to understand/debug code.  Events implicitly exist in all programs and if not explicitly utilized do not go away.</p>

<p>It is obvious that events can help you write loosely coupled class and allow multiple objects to subscribe to a single event.  However, events can also help you conform to the Tell, Don&rsquo;t Ask Principle.</p>

<h2>Tell, Don&rsquo;t Ask Principle</h2>

<p>Instead of asking an object a question about it&rsquo;s state, making a descision, and proceeding forward we should strive to tell an object what to do.</p>

<blockquote><p>Procedural code gets information then makes decisions. Object-oriented code tells objects to do things.</p>

<p>â€” Alec Sharp</p></blockquote>

<p>Let&rsquo;s look at some simple examples of a Rails controller action:</p>

<h4>Normal Rails Controller</h4>

<p>Here is an example you are sure to recognize as it is the normal way of writing a create action for a Rails controller.</p>

<div>
  <pre><code class='ruby'>class TasksController &lt; ApplicationController

  def create
    @task = Task.new(params[:task])

    if @task.save
      respond_to do |format|
        format.html { redirect_to task_path( @task ) }
      end
    else
      respond_to do |format|
        format.html { render :new }
      end
    end
  end

end</code></pre>
</div>


<p>This implementation is not good because we are examining the state of the created task to determine what to do next.  Not to mention, lots of business logic, which has nothing to do with the HTTP protocol, is happening in the controller.  How are you going to test it?</p>

<h4>Rails Controller Action With a Service Class Extracted</h4>

<p>Now, we will extract that create logic to a service class the controller can use.</p>

<div>
  <pre><code class='ruby'>class CreateTaskService

  attr_reader :task

  def initialize(attributes)
    @attributes = attributes
  end

  def call
    @task = Task.create(attributes)
  end

  def success?
    task.valid?
  end

protected

  attr_reader :attributes

end</code></pre>
</div>




<div>
  <pre><code class='ruby'>class TasksController &lt; ApplicationController

  def create
    create_service.call

    if create_service.success?
      task = create_service.task
      respond_to do |format|
        format.html { redirect_to task_path(task) }
      end
    else
      respond_to do |format|
        format.html { render :new }
      end
    end
  end

protected

  def create_service
    @create_service ||= CreateTaskService.new(params[:task])
  end

end</code></pre>
</div>


<p>While we know that extracting complex logic out of the controller into another class is a good idea, this particular implementation is just plain ugly.  The problem with this implementation is the controller is asking the service class about it&rsquo;s state and then telling it to do additional tasks.</p>

<h4>Rails Controller Action With a Service Class Extracted Utilizing Events</h4>

<p>Why not let the service class tell the controller what happened?</p>

<p>In the next example we will use the <a href="https://github.com/krisleech/wisper">wisper</a> gem to allow the controller to subscribe to events the service class may publish.</p>

<div>
  <pre><code class='ruby'>class CreateTaskService

  include Wisper::Publisher

  def initialize(attributes)
    @attributes = attributes
  end

  def call
    task = Task.create(attributes)

    if task.valid?
      publish :success, task
    else
      publish :validation_error, task
    end
  end

protected

  attr_reader :attributes

end</code></pre>
</div>




<div>
  <pre><code class='ruby'>class TasksController &lt; ApplicationController

  def create
    create_service.on :success do |task|
      respond_to do |format|
        format.html { redirect_to task_path(task) }
      end
    end

    create_service.on :validation_error do |task|
      respond_to do |format|
        format.html do 
          @task = task
          render :new
        end
      end
    end

    create_service.call
  end

protected

  def create_service
    @create_service ||= CreateTaskService.new(params[:task])
  end

end</code></pre>
</div>


<p>This is a much better implementation.  Without sacrificing the relatively linear flow of the code, we have obeyed the tell, don&rsquo;t ask principle.  In addition, we have explicitly acknowledged the presence of events, which makes the code easier to understand.</p>

<p>The ease of comprehension benefit may not seem like a big advantage in the prior example.  However, imagine the case where you are 5 levels deep in an object graph that is employing a strategy pattern.  Without the use of events to message directly to the outer most object  your only option is proxy methods.  Good luck tracing that quickly.</p>

<p>As a bonus, things get even better if we need some orthogonal piece of work to occur when the task is successfully created:</p>

<div>
  <pre><code class='ruby'>class TasksController &lt; ApplicationController

  def create
    create_service.subscribe( task_email_listener,
                              on: :success,
                              with: :task_created )

    create_service.on :success do |task|
      # ...
    end

    create_service.on :validation_error do |task|
      # ...
    end

    create_service.call
  end

protected

  def create_service
    @create_service ||= CreateTaskService.new(params[:task])
  end

  def task_email_listener
    TaskEmailListener.new
  end

end</code></pre>
</div>




<div>
  <pre><code class='ruby'>class TaskEmailListener

  def task_created( task )
    TaskMailer.assignment_email( task ).deliver
  end

end</code></pre>
</div>


<p>Wow, we have now accomplished sending an email without tightly coupling it to the <code>CreateTaskService</code> or using ActiveRecord callbacks.  This means the <code>CreateTaskService</code> can be used other places in our code without sending an email.  This also means when we create a Task in the Rails console, we will not accidentally send an email.</p>
]]></content>
  </entry>
  
</feed>
